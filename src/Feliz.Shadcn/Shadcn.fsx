#r "nuget: FSharp.Data"
#load "Common.fsx"

open System
open System.IO
open System.Text
open System.Text.RegularExpressions
open Common

// let appDir = Path.Combine(__SOURCE_DIRECTORY__, "my-app")

// if not <| Directory.Exists(appDir) then
//     Command.Run("npx", "shadcn@canary init", __SOURCE_DIRECTORY__)
//     Command.Run("npx", "shadcn@canary add --yes --overwrite --all", appDir)

let elements = File.CreateText(Path.Combine(__SOURCE_DIRECTORY__, "Shadcn.fs"))

elements.WriteLine(
    """// This file is auto-generated by the Generate.fsx script

namespace Feliz.Shadcn

[<AutoOpen>]
module Elements =
    open Fable.Core
    open Fable.Core.JsInterop
    open Feliz

    [<Erase>]
    type Shadcn ="""
)

let docElems = StringBuilder()

docElems.AppendLine(
    """// apiReferences elements begin
let apiReferencesElements: Map<string, string list> = Map ["""
)
|> ignore

for path in componentPaths do
    let contents = File.ReadAllText(path)

    if contents.Contains("variants: {") then
        printfn $"%s{path} contains variants. Add them manually to Props.fs"

    let exports =
        Regex.Matches(contents, @"export\s*{([^}]+)}")
        |> Seq.filter (fun m -> m.Success && m.Groups.Count > 0)
        |> Seq.collect (fun m -> m.Groups[1].Value.Split(",") |> Array.map _.Trim())
        |> Seq.choose (fun x -> if x.Contains " " || x = "" then None else Some x)
        |> List.ofSeq

    let filename = Path.GetFileNameWithoutExtension(path)

    let elementName =
        exports |> List.skipWhile (fun x -> Char.IsLower x[0]) |> List.head

    elements.WriteLine(
        $"""        static member inline %s{camelCase elementName} (props: list<IReactProperty>) = Interop.reactApi.createElement(import "%s{elementName}" "@/components/ui/%s{filename}", createObj !!props)"""
    )

    elements.WriteLine(
        $"""        static member inline %s{camelCase elementName} (children: #seq<ReactElement>) = Interop.reactApi.createElement(import "%s{elementName}" "@/components/ui/%s{filename}", createObj [ "children" ==> Interop.reactApi.Children.toArray (Array.ofSeq children) ])"""
    )

    docElems.AppendLine(
        $"    \"%s{camelCase elementName}\", [ \"(children: #seq<ReactElement>): ReactElement\"; \"(props: list<IReactProperty>): ReactElement\" ]"
    )
    |> ignore

    let propList =
        exports
        |> List.takeWhile (fun x -> x.StartsWith elementName)
        |> List.filter (fun x -> x <> elementName)

    if propList.Length > 0 then
        for name in propList do
            elements.WriteLine(
                $"""        static member inline %s{camelCase name} (props: list<IReactProperty>) = Interop.reactApi.createElement(import "%s{name}" "@/components/ui/%s{filename}", createObj !!props)"""
            )
            |> ignore

            elements.WriteLine(
                $"""        static member inline %s{camelCase name} (children: #seq<ReactElement>) = Interop.reactApi.createElement(import "%s{name}" "@/components/ui/%s{filename}", createObj [ "children" ==> Interop.reactApi.Children.toArray (Array.ofSeq children) ])"""
            )
            |> ignore

            elements.WriteLine(
                $"""        static member inline %s{camelCase name} (text: string) = Interop.reactApi.createElement(import "%s{name}" "@/components/ui/%s{filename}", createObj !![ prop.text text ])"""
            )

            docElems.AppendLine(
                $"    \"%s{camelCase name}\", [ \"(children: #seq<ReactElement>): ReactElement\"; \"(props: list<IReactProperty>): ReactElement\"; \"(text: string): ReactElement\" ]"
            )
            |> ignore

    elements.WriteLine("") |> ignore
    elements.Flush()

elements.Close()

docElems.AppendLine(
    """]
// apiReferences elements end"""
)
|> ignore

let docsFile = __SOURCE_DIRECTORY__ + @"/../Docs/src/Pages/_compName/Page.fs"

File.ReadAllText(docsFile)
|> fun s ->
    Regex.Replace(
        s,
        "// apiReferences elements begin(.*)// apiReferences elements end",
        docElems.ToString(),
        RegexOptions.Singleline
    )
|> fun s -> File.WriteAllText(docsFile, s)
